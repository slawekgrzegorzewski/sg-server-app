/*
 * This file is generated by jOOQ.
 */
package pl.sg.jooq.tables;


import java.math.BigDecimal;
import java.time.LocalDateTime;

import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.Name;
import org.jooq.Record;
import org.jooq.Schema;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;

import pl.sg.jooq.Public;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class NodrigenTransactionsToImport extends TableImpl<Record> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of
     * <code>public.nodrigen_transactions_to_import</code>
     */
    public static final NodrigenTransactionsToImport NODRIGEN_TRANSACTIONS_TO_IMPORT = new NodrigenTransactionsToImport();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<Record> getRecordType() {
        return Record.class;
    }

    /**
     * The column <code>public.nodrigen_transactions_to_import.id</code>.
     */
    public final TableField<Record, Long> ID = createField(DSL.name("id"), SQLDataType.BIGINT, this, "");

    /**
     * The column <code>public.nodrigen_transactions_to_import.domain_id</code>.
     */
    public final TableField<Record, Integer> DOMAIN_ID = createField(DSL.name("domain_id"), SQLDataType.INTEGER, this, "");

    /**
     * The column
     * <code>public.nodrigen_transactions_to_import.conversion_rate</code>.
     */
    public final TableField<Record, BigDecimal> CONVERSION_RATE = createField(DSL.name("conversion_rate"), SQLDataType.NUMERIC, this, "");

    /**
     * The column <code>public.nodrigen_transactions_to_import.credit</code>.
     */
    public final TableField<Record, BigDecimal> CREDIT = createField(DSL.name("credit"), SQLDataType.NUMERIC, this, "");

    /**
     * The column <code>public.nodrigen_transactions_to_import.debit</code>.
     */
    public final TableField<Record, BigDecimal> DEBIT = createField(DSL.name("debit"), SQLDataType.NUMERIC, this, "");

    /**
     * The column
     * <code>public.nodrigen_transactions_to_import.description</code>.
     */
    public final TableField<Record, String> DESCRIPTION = createField(DSL.name("description"), SQLDataType.CLOB, this, "");

    /**
     * The column
     * <code>public.nodrigen_transactions_to_import.time_of_transaction</code>.
     */
    public final TableField<Record, LocalDateTime> TIME_OF_TRANSACTION = createField(DSL.name("time_of_transaction"), SQLDataType.LOCALDATETIME(6), this, "");

    /**
     * The column
     * <code>public.nodrigen_transactions_to_import.destination_id</code>.
     */
    public final TableField<Record, Integer> DESTINATION_ID = createField(DSL.name("destination_id"), SQLDataType.INTEGER, this, "");

    /**
     * The column <code>public.nodrigen_transactions_to_import.source_id</code>.
     */
    public final TableField<Record, Integer> SOURCE_ID = createField(DSL.name("source_id"), SQLDataType.INTEGER, this, "");

    /**
     * The column
     * <code>public.nodrigen_transactions_to_import.credit_bank_account_id</code>.
     */
    public final TableField<Record, Integer> CREDIT_BANK_ACCOUNT_ID = createField(DSL.name("credit_bank_account_id"), SQLDataType.INTEGER, this, "");

    /**
     * The column
     * <code>public.nodrigen_transactions_to_import.debit_bank_account_id</code>.
     */
    public final TableField<Record, Integer> DEBIT_BANK_ACCOUNT_ID = createField(DSL.name("debit_bank_account_id"), SQLDataType.INTEGER, this, "");

    /**
     * The column
     * <code>public.nodrigen_transactions_to_import.credit_nodrigen_transaction_id</code>.
     */
    public final TableField<Record, Integer> CREDIT_NODRIGEN_TRANSACTION_ID = createField(DSL.name("credit_nodrigen_transaction_id"), SQLDataType.INTEGER, this, "");

    /**
     * The column
     * <code>public.nodrigen_transactions_to_import.debit_nodrigen_transaction_id</code>.
     */
    public final TableField<Record, Integer> DEBIT_NODRIGEN_TRANSACTION_ID = createField(DSL.name("debit_nodrigen_transaction_id"), SQLDataType.INTEGER, this, "");

    /**
     * The column
     * <code>public.nodrigen_transactions_to_import.nodrigen_transaction_id</code>.
     */
    public final TableField<Record, Integer> NODRIGEN_TRANSACTION_ID = createField(DSL.name("nodrigen_transaction_id"), SQLDataType.INTEGER, this, "");

    private NodrigenTransactionsToImport(Name alias, Table<Record> aliased) {
        this(alias, aliased, null);
    }

    private NodrigenTransactionsToImport(Name alias, Table<Record> aliased, Field<?>[] parameters) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.view("""
         create view "nodrigen_transactions_to_import" as  WITH tranasactions AS (
                 SELECT a.id,
                    a.name,
                    a.currency,
                    a.domain_id,
                    bp.institution_id,
                    nt.transaction_id,
                    nt.proprietary_bank_transaction_code,
                    nt.currency_exchange_rate,
                    nt.id AS nodrigen_transaction_id,
                    nt.currency_exchange_instructed_amount_amount,
                    nt.currency_exchange_instructed_amount_currency,
                    nt.currency_exchange_unit_currency,
                    nt.currency_exchange_source_currency,
                    nt.currency_exchange_target_currency,
                        CASE
                            WHEN (nt.transaction_amount_amount > (0)::numeric) THEN ba.id
                            ELSE NULL::integer
                        END AS credit_bank_account_id,
                        CASE
                            WHEN (nt.transaction_amount_amount < (0)::numeric) THEN ba.id
                            ELSE NULL::integer
                        END AS debit_bank_account_id,
                        CASE
                            WHEN (nt.transaction_amount_amount > (0)::numeric) THEN nt.transaction_amount_amount
                            ELSE (0)::numeric
                        END AS credit,
                        CASE
                            WHEN (nt.transaction_amount_amount > (0)::numeric) THEN (0)::numeric
                            ELSE (- nt.transaction_amount_amount)
                        END AS debit,
                    (((((COALESCE(nt.remittance_information_unstructured_array, nt.remittance_information_structured_array, nt.remittance_information_unstructured, nt.remittance_information_structured))::text || ': '::text) || (COALESCE(nt.debtor_name, ''::character varying))::text) || ' => '::text) || (COALESCE(nt.creditor_name, ''::character varying))::text) AS description,
                    LEAST(COALESCE(nt.booking_date_time, (nt.booking_date)::timestamp without time zone), COALESCE(nt.value_date_time, (nt.value_date)::timestamp without time zone)) AS time_of_transaction,
                        CASE
                            WHEN (nt.transaction_amount_amount > (0)::numeric) THEN a.id
                            ELSE NULL::integer
                        END AS destination_id,
                        CASE
                            WHEN (nt.transaction_amount_amount < (0)::numeric) THEN a.id
                            ELSE NULL::integer
                        END AS source_id
                   FROM (((nodrigen_transaction nt
                     JOIN bank_account ba ON ((nt.bank_account_id = ba.id)))
                     JOIN bank_permission bp ON ((ba.bank_permission_id = bp.id)))
                     JOIN account a ON ((ba.id = a.bank_account_id)))
                  WHERE ((nt.credit_transaction_id IS NULL) AND (nt.debit_transaction_id IS NULL) AND (nt.reset_in_id IS NULL) AND (NOT nt.ignored))
                  ORDER BY a.id, LEAST(COALESCE(nt.booking_date_time, (nt.booking_date)::timestamp without time zone), COALESCE(nt.value_date_time, (nt.value_date)::timestamp without time zone)) DESC
                )
         SELECT nextval('nodrigen_transactions_to_import_sequence'::regclass) AS id,
            tranasactions.domain_id,
            1.0 AS conversion_rate,
            tranasactions.credit,
            tranasactions.debit,
            tranasactions.description,
            tranasactions.time_of_transaction,
            tranasactions.destination_id,
            tranasactions.source_id,
            tranasactions.credit_bank_account_id,
            tranasactions.debit_bank_account_id,
                CASE
                    WHEN (tranasactions.credit > (0)::numeric) THEN tranasactions.nodrigen_transaction_id
                    ELSE NULL::integer
                END AS credit_nodrigen_transaction_id,
                CASE
                    WHEN (tranasactions.debit > (0)::numeric) THEN tranasactions.nodrigen_transaction_id
                    ELSE NULL::integer
                END AS debit_nodrigen_transaction_id,
            tranasactions.nodrigen_transaction_id
           FROM tranasactions
          WHERE (((tranasactions.institution_id)::text <> 'REVOLUT_REVOGB21'::text) OR ((tranasactions.proprietary_bank_transaction_code)::text <> 'EXCHANGE'::text))
        UNION
         SELECT nextval('nodrigen_transactions_to_import_sequence'::regclass) AS id,
            nt_debit.domain_id,
            ((nt_credit.credit / nt_debit.currency_exchange_instructed_amount_amount))::numeric(16,12) AS conversion_rate,
            nt_credit.credit,
            nt_debit.currency_exchange_instructed_amount_amount AS debit,
            nt_debit.description,
            nt_debit.time_of_transaction,
            nt_credit.destination_id,
            nt_debit.source_id,
            nt_debit.credit_bank_account_id,
            nt_debit.debit_bank_account_id,
            nt_credit.nodrigen_transaction_id AS credit_nodrigen_transaction_id,
            nt_debit.nodrigen_transaction_id AS debit_nodrigen_transaction_id,
            NULL::integer AS nodrigen_transaction_id
           FROM (tranasactions nt_debit
             JOIN tranasactions nt_credit ON (((nt_debit.transaction_id)::text = (nt_credit.transaction_id)::text)))
          WHERE (((nt_debit.institution_id)::text = 'REVOLUT_REVOGB21'::text) AND ((nt_debit.proprietary_bank_transaction_code)::text = 'EXCHANGE'::text) AND ((nt_credit.institution_id)::text = 'REVOLUT_REVOGB21'::text) AND ((nt_credit.proprietary_bank_transaction_code)::text = 'EXCHANGE'::text) AND (nt_credit.domain_id = nt_debit.domain_id) AND (nt_credit.debit = (0)::numeric) AND (nt_debit.credit = (0)::numeric))
        UNION
         SELECT nextval('nodrigen_transactions_to_import_sequence'::regclass) AS id,
            nt_debit.domain_id,
            1.0 AS conversion_rate,
            0.0 AS credit,
            (nt_debit.debit - nt_debit.currency_exchange_instructed_amount_amount) AS debit,
            ('prowizja za wymianÄ™ '::text || nt_debit.nodrigen_transaction_id) AS description,
            nt_debit.time_of_transaction,
            NULL::integer AS destination_id,
            nt_debit.source_id,
            NULL::integer AS credit_bank_account_id,
            nt_debit.credit_bank_account_id AS debit_bank_account_id,
            NULL::integer AS credit_nodrigen_transaction_id,
            nt_debit.credit_bank_account_id AS debit_nodrigen_transaction_id,
            NULL::integer AS nodrigen_transaction_id
           FROM (tranasactions nt_debit
             JOIN tranasactions nt_credit ON (((nt_debit.transaction_id)::text = (nt_credit.transaction_id)::text)))
          WHERE (((nt_debit.institution_id)::text = 'REVOLUT_REVOGB21'::text) AND ((nt_debit.proprietary_bank_transaction_code)::text = 'EXCHANGE'::text) AND ((nt_credit.institution_id)::text = 'REVOLUT_REVOGB21'::text) AND ((nt_credit.proprietary_bank_transaction_code)::text = 'EXCHANGE'::text) AND (nt_credit.domain_id = nt_debit.domain_id) AND (nt_credit.debit = (0)::numeric) AND (nt_debit.credit = (0)::numeric) AND ((nt_debit.debit - nt_debit.currency_exchange_instructed_amount_amount) > (0)::numeric));
        """));
    }

    /**
     * Create an aliased <code>public.nodrigen_transactions_to_import</code>
     * table reference
     */
    public NodrigenTransactionsToImport(String alias) {
        this(DSL.name(alias), NODRIGEN_TRANSACTIONS_TO_IMPORT);
    }

    /**
     * Create an aliased <code>public.nodrigen_transactions_to_import</code>
     * table reference
     */
    public NodrigenTransactionsToImport(Name alias) {
        this(alias, NODRIGEN_TRANSACTIONS_TO_IMPORT);
    }

    /**
     * Create a <code>public.nodrigen_transactions_to_import</code> table
     * reference
     */
    public NodrigenTransactionsToImport() {
        this(DSL.name("nodrigen_transactions_to_import"), null);
    }

    public <O extends Record> NodrigenTransactionsToImport(Table<O> child, ForeignKey<O, Record> key) {
        super(child, key, NODRIGEN_TRANSACTIONS_TO_IMPORT);
    }

    @Override
    public Schema getSchema() {
        return aliased() ? null : Public.PUBLIC;
    }

    @Override
    public NodrigenTransactionsToImport as(String alias) {
        return new NodrigenTransactionsToImport(DSL.name(alias), this);
    }

    @Override
    public NodrigenTransactionsToImport as(Name alias) {
        return new NodrigenTransactionsToImport(alias, this);
    }

    @Override
    public NodrigenTransactionsToImport as(Table<?> alias) {
        return new NodrigenTransactionsToImport(alias.getQualifiedName(), this);
    }

    /**
     * Rename this table
     */
    @Override
    public NodrigenTransactionsToImport rename(String name) {
        return new NodrigenTransactionsToImport(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public NodrigenTransactionsToImport rename(Name name) {
        return new NodrigenTransactionsToImport(name, null);
    }

    /**
     * Rename this table
     */
    @Override
    public NodrigenTransactionsToImport rename(Table<?> name) {
        return new NodrigenTransactionsToImport(name.getQualifiedName(), null);
    }
}
